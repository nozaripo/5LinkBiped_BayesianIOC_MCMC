% run a mcmc algorithm to predict/recover the mass, stiffness, and damping values
% for a mass-spring-damper system based on some reference data generated by
% 'Mass_Spring_Damper_Simulator.m' 

% written by Russell T Johnson, University of Southern California
% rtjohnso@usc.edu
% Last edited: 5/18/21

% This depends on following MCMC package for MATLAB: 
% https://mjlaine.github.io/mcmcstat/

% This also uses parallel processing toolbox in Matlab 
addpath ../MCMC_IOC/
addpath ../DirectCollocation_OC/

clear
clc
close all

user = memory;
memBefore = user.MemUsedMATLAB;

rng(99)

% True Model Values
% m_real  = 1; % mass
% c_real  = 0.20; % damping 
% k1_real = 3; % stiffness value for region 1
% k2_real = 10; % stiffness value for region 2
% T_real  = 0.03; % threshold to switch from region 1 to region 2
% x0_real = 0.1; % inital position
% xdot0_real = 0; % initial velocity 

w1_real = .2;
w2_real = .5;
w3_real = .3;


% Load Data from results
% load('position_4trials_plusnoise.mat')
% data_sol = load('Simulated_.2u^2+.5du^2+.3d3q^2.mat');
data_sol = load('Simulated_.2dq.u+.5du^2+.3d3q^2.mat');

data_sol = load('Simulated_.2du^2+.5u+.3AM.mat');

t = data_sol.soln(end).grid.time;
opt_tInt   = linspace(t(1),t(end),10*length(t)+1);
opt_xInt   = data_sol.soln(end).interp.state(opt_tInt);

% find derivative 
% velocity_noise = zeros(size(position_noise,1),size(position_noise,2)); 
% for k = 1:size(position_noise,2)
%     velocity_noise(:,k) = deriv(position_noise(:,k),0.05);
% end

% define time column for simulation
time = 0:0.05:20; 

%% set up data

% data.xdata = time';
% data.ydata = [time',position_noise,velocity_noise];

data.xInt = opt_xInt;
data.tInt = opt_tInt;


%% Set up data for different speeds
data_sol = load('Simulated_Speeds_.2dq.u+.5du^2+.3d3q^2.mat');

V_Treadmill_Array = cell2mat(data_sol.soln_map.keys);

for i_v = 1:length(V_Treadmill_Array)
    t = data_sol.soln_map(V_Treadmill_Array(i_v)).grid.time;
    data.tInt(:,:,i_v) = linspace(t(1),t(end),10*length(t)+1);
    data.xInt(:,:,i_v) = data_sol.soln_map(V_Treadmill_Array(i_v)).interp.state(data.tInt(:,:,i_v));
end
data.V_Treadmill_Array = V_Treadmill_Array;
%% Create Model

model.ssfun = @MSD_SS;
% model.priorfun = @prior_w;
model.sigma2 = 1;

%% this is the part where we do the parallelization
% must have parallel tool box installed in matlab - check first!

check = contains(struct2array(ver), 'Parallel Computing Toolbox');

if check ~=1
    error('check to see parallel toolbox is installed in matlab')
end
  
% set number of parallel pools 
n_pools = 4; 
% n_params = 7; 
n_params = 3; 

% due to simulation: create some variances based on assumptions for
% measurement accuracy - this gets used to set priors differently for each
% of the 5 parallel chains 
% m_var     = 0.30; 
% c_var     = 0.08;
% k1_var    = 0.50; 
% k2_var    = 1.00; 
% T_var     = 0.02; 
% x0_var    = 0.05; 
% xdot0_var = 0.20;

w1_var = .2;
w2_var = .2;
w3_var = .2;


% this adds 10% noise to the prior center
% prior_center = (randn(7,n_pools));
% prior_noise  = 0.1; 

prior_center = (randn(n_params,n_pools));
prior_noise  = .3; 

center_shift = .3;
init_center = .5;

% m_prior = zeros(n_pools); 
% c_prior = zeros(n_pools); 
% k1_prior = zeros(n_pools); 
% k2_prior = zeros(n_pools); 
% T_prior = zeros(n_pools); 
% x0_prior = zeros(n_pools); 
% xdot0_prior = zeros(n_pools); 

w1_prior = zeros(n_pools);
w2_prior = zeros(n_pools);
w3_prior = zeros(n_pools);


for j = 1:n_pools
%     m_prior(j) = m_real + (prior_center(1,j) * (m_var*prior_noise));
%     c_prior(j) = c_real + (prior_center(2,j) * (c_var*prior_noise));
%     k1_prior(j) = k1_real + (prior_center(3,j) * (k1_var*prior_noise));
%     k2_prior(j) = k2_real + (prior_center(4,j) * (k2_var*prior_noise));
%     T_prior(j) = T_real + (prior_center(5,j) * (T_var*prior_noise));
%     x0_prior(j) = x0_real + (prior_center(6,j) * (x0_var*prior_noise));
%     xdot0_prior(j) = xdot0_real  + (prior_center(7,j) * (xdot0_var*prior_noise)); % can't multiply by 0
    
% %     w1_prior(j) = w1_real + center_shift + (prior_center(1,j) * (w1_var*prior_noise));
% %     w2_prior(j) = w2_real + center_shift + (prior_center(2,j) * (w2_var*prior_noise));
% %     w3_prior(j) = w3_real + center_shift + (prior_center(3,j) * (w3_var*prior_noise));
    
    
    w1_prior(j) = init_center + (prior_center(1,j) * (w1_var*prior_noise));
    w2_prior(j) = init_center + (prior_center(2,j) * (w2_var*prior_noise));
    w3_prior(j) = init_center + (prior_center(3,j) * (w3_var*prior_noise)); 
    
%     w1_prior(j) = unifrnd(0,1);
%     w2_prior(j) = unifrnd(0,1);
%     w3_prior(j) = unifrnd(0,1);
end

% m = zeros(n_pools); 
% c = zeros(n_pools); 
% k1 = zeros(n_pools); 
% k2 = zeros(n_pools); 
% T = zeros(n_pools); 
% x0 = zeros(n_pools); 
% xdot0 = zeros(n_pools); 

w1 = zeros(n_pools);
w2 = zeros(n_pools);
w3 = zeros(n_pools);


% define initial parameters based on prior for each chain
for j = 1:n_pools
%     m(j)     = m_prior(j) + randn(1,1) * m_var;
%     c(j)     = c_prior(j) + randn(1,1) * c_var;
%     k1(j)    = k1_prior(j) + randn(1,1) * k1_var;
%     k2(j)    = k2_prior(j) + randn(1,1) * k2_var;
%     T(j)     = T_prior(j) + randn(1,1) * T_var;
%     x0(j)    = x0_prior(j) + randn(1,1) * x0_var;
%     xdot0(j) = xdot0_prior(j) + randn(1,1) * xdot0_var;
    

    w1(j) = w1_prior(j) + randn(1,1) * w1_var;
    w2(j) = w2_prior(j) + randn(1,1) * w2_var;
    w3(j) = w3_prior(j) + randn(1,1) * w3_var;
        
%     w1(j) = w1_prior(j);
%     w2(j) = w2_prior(j);
%     w3(j) = w3_prior(j);
end

% if any of model parameter numbers are less than zero, the dynamics of the system
% breaks and everything dies, so check to see if the initial proposals come
% out to be < 0 and then reset them to arbitrary positive values. 

for j = 1:n_pools
%     if m(j) <0
%         m(j)  = m_real  + randn(1,1)* 0.05;
%     end
%     if c(j) < 0
%         c(j)  = c_real  + randn(1,1)* 0.05;
%     end
%     if k1(j) < 0
%         k1(j) = k1_real + randn(1,1)* 0.1;
%     end
%     if k2(j) < 0 
%         k2(j) = k2_real + randn(1,1)* 0.1; 
%     end
%     if T(j) < 0
%         T(j)  = T_real  + randn(1,1)* 0.1;
%     end
    
    
    if w1(j) <0
        w1(j)  = w1_real +center_shift + randn(1,1)* 0.05;
    end
    if w2(j) <0
        w2(j)  = w2_real +center_shift + randn(1,1)* 0.05;
    end
    if w3(j) <0
        w3(j)  = w3_real +center_shift + randn(1,1)* 0.05;
    end

end

% titles = ["m", "c", "k1", "k2", "T", "x0", "xdot0"];
titles = ["w1", "w2", "w3"];
set_thetamu = 0; 
set_thetasig = 0.2;
set_thetasig = 5;
set_thetasig = .5;

Init_Parameter = zeros(n_params,n_pools);
Init_Parameter(:,1) = ones(1,3).*-1;

for i = 1:n_pools
    Init_Parameter(:,i) = 0 + 1*rand(1,3);  
end

lower_bound = 0; % set lower bound for amplitudes 
upper_bound = 1; % set upper bound for amplitudes 
% lower_bound = -30; % set lower bound for amplitudes 
% upper_bound = 30; % set upper bound for amplitudes 

params = cell(n_params,n_pools); 
for i = 1:n_pools
%     params(:,i) = { 
%         {'m',    m(i),       0, 50,  m_prior(i),     (m_var*2)} 
%         {'c',    c(i),       0, 10,  c_prior(i),     (c_var*2)}
%         {'k1',   k1(i),      0, 50,  k1_prior(i),    (k1_var*2)}
%         {'k2',   k2(i),      0, 50,  k2_prior(i),    (k2_var*2)}
%         {'T',    T(i),       0,  2,  T_prior(i),     (T_var*2)}
%         {'x0',   x0(i)    -2,  2,  x0_prior(i),    (x0_var*2)}
%         {'xdot0',xdot0(i),-20, 20, xdot0_prior(i), (xdot0_var*2)}
%         };
    
%     params(:,i) = { 
%         {'w1',   Init_Parameter(1,i),      0, 1,  w1_prior(i),     (w1_var*2)} 
%         {'w2',   Init_Parameter(2,i),      0, 1,  w2_prior(i),     (w2_var*2)}
%         {'w3',   Init_Parameter(3,i),      0, 1,  w3_prior(i),     (w3_var*2)}
%         };
    
    params(:,i) = { 
        {'w1',   Init_Parameter(1,i),      lower_bound, upper_bound,  w1_prior(i),     inf} 
        {'w2',   Init_Parameter(2,i),      lower_bound, upper_bound,  w2_prior(i),     inf}
        {'w3',   Init_Parameter(3,i),      lower_bound, upper_bound,  w3_prior(i),     inf}
        };
%     params(:,i) = { 
%         {'w1',   Init_Parameter(1,i),      lower_bound, upper_bound,  set_thetamu,     set_thetasig} 
%         {'w2',   Init_Parameter(2,i),      lower_bound, upper_bound,  set_thetamu,     set_thetasig}
%         {'w3',   Init_Parameter(3,i),      lower_bound, upper_bound,  set_thetamu,     set_thetasig}
%         };
end

% set up the options for mcmcrun 
options.nsimu = 200;
options.stats = 1; 
options.stats2 = 1; 
options.waitbar = 0;

% define burn-in as a percentage of the number of simulations... 
burn_in = options.nsimu *0.80;

% start the clock
tic

% Open the parallel pools 
poolobj = parpool(n_pools);

% ----------------- DO THE MCMC!!!! -------------------------------
parfor k = 1:n_pools
% for k = 1:n_pools
    [results(:,:,k), chain(:,:,k), s2chain(:,:,k)]= mcmcrun(model,data,params(:,k),options);
end

% Stop the clock
runtime = toc/3600

% stop the parallel pools
% delete(poolobj)

% assemble the results
results_one = results(:,:,1);
results_two = results(:,:,2);
results_thr = results(:,:,3); 
results_for = results(:,:,4);
% results_fiv = results(:,:,5); 

% plot the chains
figure(9);
set(gcf,'units','centimeters','Position',[7.5935 4.2863 20 12])
for i =1:size(chain,2)
    subplot(2,4,i)
    plot(chain(:,i,1),'k')
    hold on 
    plot(chain(:,i,2),'b')
    hold on 
    plot(chain(:,i,3),'r')
    hold on 
    plot(chain(:,i,4),'g')
%     hold on 
%     plot(chain(:,i,5),'c')
    title(titles{i})
    xlabel('iteration')
    ylabel('value')
    box off
end

% plot more results from MCMC toolbox - this creates a bunch of plots,
% uncomment if you want to look at each of the chains
for i = 1:size(chain,3)
    figure(); clf
    set(gcf,'units','centimeters','Position',[7.5935 4.2863 10 13])
    mcmcplot(chain(burn_in:end,:,i),[],results(:,:,i),'pairs');

    figure(); clf
    set(gcf,'units','centimeters','Position',[7.5935 4.2863 10 13])
    mcmcplot(chain(burn_in:end,:,i),[],results(:,:,i),'denspanel',2);
    hold on 

    figure(); clf
    set(gcf,'units','centimeters','Position',[7.5935 4.2863 10 13])
    mcmcplot(chain(burn_in:end,:,i),[],results(:,:,i),'denspanel2',2);
end

% do 10 random draws from each chain, then plot the results to see how
% the results fit the data
n_draws = 15; 
Draw = zeros(n_draws); 
Draw_Results = zeros(n_draws,n_params); 
% y0 = zeros(n_draws,2,n_pools); 
% t = zeros(length(time),n_draws); 
time = opt_tInt;
oscillator = zeros(n_draws*2,length(time),n_pools); 

for i = 1:n_pools
    for k = 1:n_draws
       Draw(k) = randi([burn_in options.nsimu]);
       Draw_Results(k,:,i) = chain(Draw(k),:,i);
%        y0(k,:,i) = [Draw_Results(k,6,i),Draw_Results(k,7,i)];
%        [t(:,k),oscillator(:,k*2-1:k*2,i)] = ode15s(@MSD_sys,time,y0(k,:,i),[],Draw_Results(k,:,i));
       [xInt,~] = ForwardSimulation_simple(Draw_Results(k,:,i));
       limb_angles(k*10-9:k*10,:,i) = xInt;
    end
end

% plot the random draws 
% figure()
set(gcf,'units','centimeters','Position',[7.5935 4.2863 20 13])
for i = 1:n_pools
    figure(101)
    subplot(2,2,i)
    for k = 1:n_draws
        plot(time,limb_angles(k*10-9:k*10-5,:,i),'color',[.17 .17 .17],'LineWidth',1.5)
        hold on 
    end
    h1 = plot(time,data.xInt(1:5,:),'r--','LineWidth',1.5);
    hold on
%     for k = 2:4
%          plot(time,position_noise(:,k),'r--','LineWidth',2);
%     end
    if i == 1
        legend(h1,'Ref. Trajectory')
        legend('boxoff')
    end
    set(gca,'fontsize',10)
    xlabel('Time (s)')
    ylabel('Angle (rad)')
    box off
    title(['Result from worker No. ', num2str(i)])
    
    
    figure(102)
    subplot(2,2,i)
    for k = 1:n_draws
        plot(time,limb_angles(k*10-6:k*10,:,i),'color',[.17 .17 .17],'LineWidth',1.5)
        hold on 
    end
    h1 = plot(time,data.xInt(6:10,:),'r--','LineWidth',1.5);
    hold on
%     for k = 2:4
%          plot(time,position_noise(:,k),'r--','LineWidth',2);
%     end
    if i == 1
        legend(h1,'Ref. Trajectory')
        legend('boxoff')
    end
    set(gca,'fontsize',10)
    xlabel('Time (s)')
    ylabel('Velocity (rad/s)')
    box off
    title(['Result from worker No. ', num2str(i)])
end 


End_results_worker1 = chain(end,:,1)';
End_results_worker2 = chain(end,:,2)';
End_results_worker3 = chain(end,:,3)';
End_results_worker4 = chain(end,:,4)';
True_Weights = [.2, .5, .3]';
table(End_results_worker1, End_results_worker2, End_results_worker3, End_results_worker4, True_Weights, 'RowNames', {'w1', 'w2' , 'w3'})

% Plot the rank without the first burn in 
rank_plot_MSD(chain(burn_in:end,:,:),options,n_pools);

% Plot the density of 
results_one_dist = mvnrnd(results_one.mean, results_one.cov, 2000);

figure(20)
histogram(results_one_dist(:,1))

% save the chains so that we can do other analysss later if we want
filename = ['chain_',datestr(now,'yyyymmddTHHMMSS'),'.mat'];
save(filename,'chain');
filename = ['results_',datestr(now,'yyyymmddTHHMMSS'),'.mat'];
save(filename,'results');

user = memory;
memAfter = user.MemUsedMATLAB;

% return

% display some stuff about the MCMC run
disp('========================== ' )
disp(['Elapsed Time = ' num2str(floor(runtime)) ' hr(s) & ' num2str(floor((runtime-floor(runtime))*60)) ' mins'])
disp(['change in Matlab memory use = ' num2str((memAfter - memBefore)/1e6) ' MB'])
disp('   ')

%% End of main function, begin other functions

function ss = MSD_SS(W,data)
    % sum of squares function for the posterior probability 

%     time   = data.xdata;
%     ydata  = data.ydata(:,2:end); % just takes the position data

%     y0 = [theta(6),theta(7)];
%     
%     ymodel = MSD_fun(time,theta,y0);
%     n_trials = 4; 
%     
%     sumsquare = zeros(n_trials); % sum the squared error over all four "trials"
%     for i = 1:n_trials
%         sumsquare(i) = sum(((ymodel(:,1) - ydata(:,i))/0.10).^2);
%     end
%     ss = sum(sumsquare);


W1 = W;
% % W1 = 1./(1 + exp(-W));

% [xInt,~] = ForwardSimulation_simple(W1);
[xInt,tInt] = ForwardSimulation_Speeds_simple(W1, data.V_Treadmill_Array);

% ss = rms(rms(xInt-data.xInt,2));
ss = sum(sum(rms(xInt - data.xInt,2))) + 10*(norm( tInt(end) - data.tInt(end) ));


end

function y=MSD_fun(time,theta,y0)
    % integration of the mass spring damper system 
    [t,y] = ode15s(@MSD_sys,time,y0,[],theta);

end

function ydot = MSD_sys(t,y,theta)
    % ode system function for MCMC mass spring damper example
    
    m = theta(1);
    c = theta(2); 
    k1 = theta(3); % stiffness value for region 1
    k2 = theta(4); % stiffness value for region 2
    T  = theta(5);
    
    if (-T<y(1)) && (y(1)<T)
        A = [0 1; -k1/m -c/m];
    else 
        A = [0 1; -(((k1*T)/(abs(y(1)))-(k2*T)/(abs(y(1)))+k2))/m -c/m];
    end
    
    ydot = A*y ;

end

function prior = prior_w(theta,mu,sig) % mu,sig not used here, but mcmcrun needs some values to pass around. 
%     tfinal = 0.5;
%     h = 0.001;
%     time = (0:h:tfinal)';
%     Muscle_1 = theta(1:10);
%     Muscle_2 = theta(11:20);
%     Muscle_3 = theta(21:30);
%     Muscle_4 = theta(31:40);
%     Muscle_5 = theta(41:50);
%     Muscle_6 = theta(51:60);
%     
%     controls(:,1) = CRBF_excit(time,Muscle_1);
%     controls(:,2) = CRBF_excit(time,Muscle_2);
%     controls(:,3) = CRBF_excit(time,Muscle_3);
%     controls(:,4) = CRBF_excit(time,Muscle_4);
%     controls(:,5) = CRBF_excit(time,Muscle_5);
%     controls(:,6) = CRBF_excit(time,Muscle_6);
%     
%     SumIntegExc = 0;
%     
%     for k = 1:6
%         SumIntegExc = SumIntegExc + (h * trapz(controls(:,k).^3));
%     end
%     
%     P = 0.07; % sum of muscle excitations from reference motion
%     prior = ((SumIntegExc - P)/.05)^2;
    prior = 0;
end 